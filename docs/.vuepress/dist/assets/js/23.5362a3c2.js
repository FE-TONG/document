(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{208:function(n,t,e){"use strict";e.r(t);var r=e(0),s=Object(r.a)({},function(){var n=this.$createElement,t=this._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v(" /* \n      创建对象三种方法 \n      1. 字面声明\n      2. new\n      3， Object.create\n    */\n/* \n      Object.create 实现原理\n      1. 建个function\n      2. 函数的prototype 指向 传进来 的 p\n      3. return new F()\n     */\n\n/* \n      new 实现原理\n      1. 一个新对象被创建， 它继承自foo.prototype\n      2. 构造函数被执行。上下文（this）指定为这个新实例 ，相应参数会被传人\n      3. 如果构造函数返回一个对象， 那么这个对象会取代整个new 出来的结果, 如果没有返回对象，那么new 出来的结果就是步骤一 的新对象\n     */\n\n    this\n    call\n    apply\n    bind\n/* \n      __proto__   prototype\n      constructor   构造器\n     */\n/* \n      类的声明\n      1. class\n      2. 构造器 constructor\n     */\n\n/* \n      类的继承\n      1. 借助constructor来继承\n      2. es6继承\n     */\n\n/* \n  valueOf         涉及到值运算         用valueOf\n  toString        转为字符串，显示      用toString\n  柯里化 ? 缓存\n  实现 \n  1. add(1,2,3,4)\n  2. add(1)(2)(3)(4)\n  3. add(1,2,3)(1)(3,4,5)(99)\n*/\n\n/* \n  数组\n  文档\n  */\n\n\n/* \n  去重\n  1. 直接两个遍历，在里面留个标识，判断 是否push\n  2. 排序，然后第一个和第二个比\n  3. object\n  4. es6  Array.from(new Set(a)); || ...\n  */\n\n  \n\n/* \n  restArguments\n  */\n")])])])])},[],!1,null,null,null);t.default=s.exports}}]);