(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{199:function(t,a,v){"use strict";v.r(a);var _=v(0),e=Object(_.a)({},function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"http"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http","aria-hidden":"true"}},[t._v("#")]),t._v(" http")]),t._v(" "),v("h2",{attrs:{id:"http报文组成部分"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http报文组成部分","aria-hidden":"true"}},[t._v("#")]),t._v(" http报文组成部分")]),t._v(" "),v("h3",{attrs:{id:"请求报文"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#请求报文","aria-hidden":"true"}},[t._v("#")]),t._v(" 请求报文")]),t._v(" "),v("ul",[v("li",[t._v("请求行   http方法  页面地址 http协议以及 版本")]),t._v(" "),v("li",[t._v("请求头  一些 key&value")]),t._v(" "),v("li",[t._v("空行   遇到空行 服务端就知道下面内容就是请求体了（相当于分隔符）")]),t._v(" "),v("li",[t._v("请求体")])]),t._v(" "),v("h3",{attrs:{id:"响应报文"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#响应报文","aria-hidden":"true"}},[t._v("#")]),t._v(" 响应报文")]),t._v(" "),v("p",[t._v("状态行  响应头 空行   响应体")]),t._v(" "),v("h2",{attrs:{id:"http方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http方法","aria-hidden":"true"}},[t._v("#")]),t._v(" http方法")]),t._v(" "),v("ul",[v("li",[t._v("get  获取资源")]),t._v(" "),v("li",[t._v("post  传输资源")]),t._v(" "),v("li",[t._v("put    更新资源")]),t._v(" "),v("li",[t._v("delete  删除资源")]),t._v(" "),v("li",[t._v("head    获取报文首部")])]),t._v(" "),v("h3",{attrs:{id:"get与post区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#get与post区别","aria-hidden":"true"}},[t._v("#")]),t._v(" get与post区别")]),t._v(" "),v("ul",[v("li",[t._v("get在浏览器回退时是无害的，而post会再次提交请求")]),t._v(" "),v("li",[t._v("get请求会被浏览器主动缓存，而post不会，除非手动设置")]),t._v(" "),v("li",[t._v("get请求参数会被完整保留在浏览器历史记录，而post中的参数不会被保留")]),t._v(" "),v("li",[t._v("get请求在url中传送的参数有长度限制的，而post没有限制")]),t._v(" "),v("li",[t._v("get参数通过url传递，post放在request body中")]),t._v(" "),v("li",[t._v("get请求只能进行url编码，而post支持多种")]),t._v(" "),v("li",[t._v("get比post更不安全，因为参数直接暴露在url上")])]),t._v(" "),v("h2",{attrs:{id:"http特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http特性","aria-hidden":"true"}},[t._v("#")]),t._v(" http特性")]),t._v(" "),v("ul",[v("li",[t._v("无状态")]),t._v(" "),v("li",[t._v("无连接")])]),t._v(" "),v("h2",{attrs:{id:"http状态吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http状态吗","aria-hidden":"true"}},[t._v("#")]),t._v(" http状态吗")]),t._v(" "),v("ul",[v("li",[t._v("1xx: 指示信息 - 表示请求已接收，继续处理")]),t._v(" "),v("li",[t._v("2xx: 成功  表示请求已被成功接收")]),t._v(" "),v("li",[t._v("3xx: 重定向   要完成请求必须进行更进一步的操作")]),t._v(" "),v("li",[t._v("4xx: 客户端错误   请求有语法错误或请求无法实现")]),t._v(" "),v("li",[t._v("5xx:  服务端报错")])]),t._v(" "),v("h3",{attrs:{id:"常用状态码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常用状态码","aria-hidden":"true"}},[t._v("#")]),t._v(" 常用状态码")]),t._v(" "),v("ul",[v("li",[t._v("200 ok 客户端请求成功")]),t._v(" "),v("li",[t._v("206  客户")]),t._v(" "),v("li",[t._v("301  请求的页面已经转移至新的url")]),t._v(" "),v("li",[t._v("304  客户端有缓存的文档并发出了一个条件性的请求，服务器告诉客户，原来缓存的文档还可以继续使用")])]),t._v(" "),v("h2",{attrs:{id:"http持久连接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http持久连接","aria-hidden":"true"}},[t._v("#")]),t._v(" http持久连接")]),t._v(" "),v("p",[t._v("http1.1 之后才可以使用  持久连接")]),t._v(" "),v("p",[t._v("http协议采用 “请求-应答”模式，当使用普通模式， 即非keep-alive模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（http协议为无连接的协议）")]),t._v(" "),v("p",[t._v("当使用keep-alive模式（又称持久连接、连接重用）时， keep-alive功能使客户端到服务端的连接持续有效，当出现对服务器的后续请求时，keep-alive 功能避免了建立或者重新建立连接。")]),t._v(" "),v("h2",{attrs:{id:"管线化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#管线化","aria-hidden":"true"}},[t._v("#")]),t._v(" 管线化")]),t._v(" "),v("p",[t._v("把请求1 请求2 请求3  打包")]),t._v(" "),v("p",[t._v("然后响应1 响应2 响应3 打包回来")]),t._v(" "),v("p",[t._v("机制通过持久连接完成，http1.1 支持")]),t._v(" "),v("p",[t._v("只有get 和head 请求 可以进行管线化，而post 有所限制")]),t._v(" "),v("p",[t._v("默认浏览器不支持管线化")])])},[],!1,null,null,null);a.default=e.exports}}]);